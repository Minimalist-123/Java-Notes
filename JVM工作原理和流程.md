JVM的体系结构

Java是一种技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如下图所示：


运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。

Java平台由Java虚拟机和Java应用程序接口搭建，Java语言则是进入这个平台的通道，用Java语言编写并编译的程序可以运行在这个平台上。这个平台的结构如下图所示：




在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。 

JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。下面我们从JVM的体系结构和它的运行过程这两个方面来对它进行比较深入的研究。

JVM类加载机制

·每个JVM都有两种机制：

①类装载子系统：装载具有适合名称的类或接口

②执行引擎：负责执行包含在已装载的类或接口中的指令 

·每个JVM都包含：

方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器









对于JVM的学习，在我看来这么几个部分最重要：

Java代码编译和执行的整个过程

JVM内存管理及垃圾回收机制

下面分别对这几部分进行说明：

下面我们来解析这几个区域

1、程序计数器：

指向当前线程正在执行的字节码指令。线程私有的。

2、虚拟机栈：

虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。

（1）栈帧：栈帧存储方法的相关信息，包含局部变量数表、返回值、操作数栈、动态链接

a、局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。

b、返回值：如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。

c、操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）。操作数栈的的元素可以是任意Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。

d、动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。

（2）线程私有

3、本地方法栈：

（1）调用本地native的内存模型

（2）线程独享。

4、方法区：

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据

（1）线程共享的

（2）运行时常量池：

A、是方法区的一部分

B、存放编译期生成的各种字面量和符号引用

C、Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池中。

5、Java 堆

JMM Java内存模型：

1、 Java的并发采用“共享内存”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据交互的，它们之间交互只能通过共享变量实现。

2、 主要目的是定义程序中各个变量的访问规则。

3、 Java内存模型规定所有变量都存储在主内存中，每个线程还有自己的工作内存。

（1） 线程的工作内存中保存了被该线程使用到的变量的拷贝（从主内存中拷贝过来），线程对变量的所有操作都必须在工作内存中执行，而不能直接访问主内存中的变量。

（2） 不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递都要通过主内存来完成。

（3） 主内存主要对应Java堆中实例数据部分。工作内存对应于虚拟机栈中部分区域。




4、Java线程之间的通信由内存模型JMM（Java Memory Model）控制。

（1）JMM决定一个线程对变量的写入何时对另一个线程可见。

（2）线程之间共享变量存储在主内存中

（3）每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。

（4）JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。

5、可见性、有序性：

（1）当一个共享变量在多个本地内存中有副本时，如果一个本地内存修改了该变量的副本，其他变量应该能够看到修改后的值，此为可见性。

（2）保证线程的有序执行，这个为有序性。（保证线程安全）

6、内存间交互操作：

（1）lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。

（2）unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

（3）read（读取）：作用于主内存变量，把主内存的一个变量读取到工作内存中。

（4）load（载入）：作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中

（5）use（使用）：作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎。

（6）assign（赋值）：作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量。

（7）store（存储）：把工作内存的变量的值传递给主内存

（8）write（写入）：把store操作的值入到主内存的变量中

6.1、注意：

（1）不允许read、load、store、write操作之一单独出现

（2）不允许一个线程丢弃assgin操作

（3）不允许一个线程不经过assgin操作，就把工作内存中的值同步到主内存中

（4）一个新的变量只能在主内存中生成

（5）一个变量同一时刻只允许一条线程对其进行lock操作。但lock操作可以被同一条线程执行多次，只有执行相同次数的unlock操作，变量才会解锁

（6）如果对一个变量进行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assgin操作初始化变量的值。

（7）如果一个变量没有被锁定，不允许对其执行unlock操作，也不允许unlock一个被其他线程锁定的变量

（8）对一个变量执行unlock操作之前，需要将该变量同步回主内存中

堆的内存划分：

Java堆的内存划分如图所示，分别为年轻代、Old Memory（老年代）、Perm（永久代）。其中在Jdk1.8中，永久代被移除，使用MetaSpace代替。

1、新生代：

（1）使用复制清除算法（Copinng算法），原因是年轻代每次GC都要回收大部分对象。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。

（2）分为Eden、Survivor From、Survivor To，比例默认为8：1：1

（3）内存不足时发生Minor GC

2、老年代：

（1）采用标记-整理算法（mark-compact），原因是老年代每次GC只会回收少部分对象。

3、Perm：用来存储类的元数据，也就是方法区。

（1）Perm的废除：在jdk1.8中，Perm被替换成MetaSpace，MetaSpace存放在本地内存中。原因是永久代进场内存不够用，或者发生内存泄漏。

（2）MetaSpace（元空间）：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。

4、堆内存的划分在JVM里面的示意图：





GC垃圾回收：

一、 判断对象是否要回收的方法：可达性分析法

1、 可达性分析法：通过一系列“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，并且root对象引用的对象也是不可回收的）

2、 以下对象会被认为是root对象：

（1） 虚拟机栈（栈帧中本地变量表）中引用的对象

（2） 方法区中静态属性引用的对象

（3） 方法区中常量引用的对象

（4） 本地方法栈中Native方法引用的对象

3、 对象被判定可被回收，需要经历两个阶段：

（1） 第一个阶段是可达性分析，分析该对象是否可达

（2） 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。（finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会）

4、 方法区中的垃圾回收：

（1） 常量池中一些常量、符号引用没有被引用，则会被清理出常量池

（2） 无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：

A、 该类的所有实例被回收

B、 加载该类的ClassLoader被回收

C、 该类的Class对象没有被引用

5、 finalize():

（1） GC垃圾回收要回收一个对象的时候，调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。

（2） 可以在该方法里面，指定一些对象在释放前必须执行的操作。

二、 发现虚拟机频繁full GC时应该怎么办：

（full GC指的是清理整个堆空间，包括年轻代和永久代）

（1） 首先用命令查看触发GC的原因是什么 jstat –gccause 进程id

（2） 如果是System.gc()，则看下代码哪里调用了这个方法

（3） 如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令

（4） 如果是GC locker，可能是程序依赖的JNI库的原因

三、常见的垃圾回收算法：

1、Mark-Sweep（标记-清除算法）：

（1）思想：标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。

（2）优缺点：实现简单，容易产生内存碎片

2、Copying（复制清除算法）：

（1）思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。

（2）优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。

3、Mark-Compact（标记-整理算法）：

（1）思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。

（2）优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下

4、分代收集算法：（目前大部分JVM的垃圾收集器所采用的算法）：

思想：把堆分成新生代和老年代。（永久代指的是方法区）

（1） 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。

（2） 由于老年代每次只回收少量的对象，因此采用mark-compact算法。

（3） 在堆区外有一个永久代。对永久代的回收主要是无效的类和常量

5、GC使用时对程序的影响？ 

垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，然后释放没用对象，这个过程消耗处理器时间

6、几种不同的垃圾回收类型：

（1）Minor GC：从年轻代（包括Eden、Survivor区）回收内存。

A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC

B、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。

（2）Major GC：清理整个老年代，当eden区内存不足时触发。

（3）Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发

6、直接内存

直接内存（Direct Memory）虽然不是程序运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，而且它也可能导致OutOfMemoryError异常出现。

在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native方法库直接分配堆外内存，然后通过一个存储在Java堆里面的DirecByteBuffer对象作为这块内存的引用进行操作。这样能在某些应用场景中显著提高性能，因为它避免了在Java堆和Native堆中来回复制数据。

显然，本机直接内存的分配不会受到Java堆大小的限制，但是，还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制，从而导致动态扩展时出现OutOfMemoryError异常。

7、执行引擎

将字节码即时编译 优化 为本地代码， 然后执行。

在了解完这些知识以后，就可以知道：类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？

在程序运行时类是在方法区，实例对象本身在堆里面。

方法字节码在方法区。线程调用方法执行时创建栈帧并压栈，方法的参数和局部变量在栈帧的局部变量表。

对象的实例变量和对象一起在堆里，所以各个线程都可以共享访问对象的实例变量。

静态变量在方法区，所有对象共享。字符串常量等常量在运行时常量池。

各线程调用的方法，通过堆内的对象，方法区的静态数据，可以共享交互信息。

各线程调用的方法所有参数传递、方法返回值的返回，都是使用栈帧里的操作数栈来完成的。

参考：

https://blog.csdn.net/qq_33384065/article/details/80282023

https://segmentfault.com/a/1190000014395186

作者：步二小哥
链接：https://www.jianshu.com/p/7b7422c65f0a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
