前言
在java中摸索几年,在看一些文章中,时间复杂度的词频挺高,是时候看下了,而且也是基础,当是回温一下大学的知识,不能全还给老师,哈哈

概念
**时间复杂度:**用来定性的描述算法的执行时间的一个函数,更类似于一个耗时的趋势,函数表示为: O(f(n))

名词解释:
n:问题的规模,重复执行的次数
T(n):一段程序运行,各种操作代码所执行的总次数
f(n): 存在的某个函数,使得T(n)/f(n)=非零常数,	那么f(n)称为T(n)的同数量级函数
O:大O符号,一种符号,表示渐进于无穷的行为

穿起来:
算法中各种代码操作所执行的总次数用T(n)表示,存在某个函数f(n),使得T(n)/f(n)=非零常数,那么f(n)称为T(n)的同数量级函数(类想一下,在坐标轴中,当入参n趋于无穷时,两条曲线的商为常数),即:T(n)=O(f(n)),O(f(n))就是时间复杂度.O符号表示一个渐进常数. 在这个函数中可以忽略低阶项和首项系数,中文例二解释.

正文
1.没怎么研究过算法,但算法是程序的灵魂,算法决定性能,算法分为时间复杂度和空间复杂度,这也是常说"时间换空间,空间换时间"由来了
2.看上面概念已经基本知道时间复杂度是个什么东西了,下面看些例子,由简入深.
2.1	时间复杂度为:O(1)

    public void fun1() {
        int n = 100;//没有入参变量,执行规模永远为1行
    }
1
2
3
2.2 时间复杂度为:O(n)

  public void fun1() {
        int n = 100;//执行次数:1
        int sum = 0;//执行次数:1
        for (int j = 1; j <= n; ++j) {//执行次数:n
            sum += j;//执行次数:n
        }
    }
1
2
3
4
5
6
7
所以T(n)=1+1+n+n=2n+2 = n,即时间复杂度为:O(n),时间复杂度是表示一个函数的趋势,并不代表具体值,当n趋于无穷大时,可以忽略低阶项和首项系数

2.3 时间复杂度为:O(n²)

 public void fun1() {
        int n = 100;//执行次数:1
        int sum = 0;//执行次数:1
        for (int i = 1; i <= n; ++i) {//执行次数:n
            for (int j = 1; j <= n; ++j) {//执行次数:n*n
                sum += j;//执行次数:n*n
            }
        }
    }
1
2
3
4
5
6
7
8
9
T(n)=1+1+n+nn+nn=2n²+2n+2=n²
…
常规的代码的算法是有规律的:看几重循环:只有一重则时间复杂度为O(n)，二重为O(n^2);如果有二分则为O(logn)，二分例如快速幂、二分查找，如果一个for循环套一个二分，那么时间复杂度则为O(nlogn)。

分类:
常见时间复杂度有(按增长率):
1.常数阶O(1)
2.对数阶O(logn)
3.线性阶O(n)
4.线性对数阶O(nlog2n)
5.k方阶:O(n^k),一般控制k的大小,否则就和指数阶一样了,这是很可怕的
6.指数阶:O(2^n),一般不用,性能太差

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

我不能保证理解都是对的和实践都是最佳的,这是个人的一些理解和实践,如发现问题,请联系笔者做出更改,交流->分享->进步.

认真工作,热爱生活.享受现在,拥抱未来~
————————————————
版权声明：本文为CSDN博主「四月天五月雨」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_40533111/article/details/83027707
